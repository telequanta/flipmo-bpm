<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flipmo BPM Tool</title>
</head>
<body>
  <h1>Flipmo BPM Tool</h1>
  <input type="file" id="audioFile" accept="audio/*">
  <div id="bpm">BPM: --</div>

  <script>
    let audioContext;
    let source;
    let analyser;
    let dataArray;
    let bufferLength;
    let lastPeakTime = 0;
    let peakTimes = [];
    let bpmHistory = [];
    const rollingAverageSize = 12;
    const minBPM = 80;
    const maxBPM = 160;
    const energyThreshold = 0.2;
    const minPeakInterval = 0.3; // seconds

    document.getElementById('audioFile').addEventListener('change', function(e) {
      if (audioContext) {
        audioContext.close();
      }

      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function(event) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContext.decodeAudioData(event.target.result, function(buffer) {
          source = audioContext.createBufferSource();
          source.buffer = buffer;

          const bandpass = audioContext.createBiquadFilter();
          bandpass.type = "bandpass";
          bandpass.frequency.value = 1000; // center frequency
          bandpass.Q.value = 1; // width

          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);

          source.connect(bandpass);
          bandpass.connect(analyser);
          analyser.connect(audioContext.destination);

          source.start();
          detectBeats();
        });
      };
      reader.readAsArrayBuffer(file);
    });

    function detectBeats() {
      setInterval(() => {
        analyser.getByteTimeDomainData(dataArray);

        let energy = 0;
        for (let i = 0; i < bufferLength; i++) {
          let val = (dataArray[i] - 128) / 128;
          energy += val * val;
        }
        energy /= bufferLength;

        let currentTime = audioContext.currentTime;
        if (energy > energyThreshold && (currentTime - lastPeakTime) > minPeakInterval) {
          lastPeakTime = currentTime;
          peakTimes.push(currentTime);

          if (peakTimes.length > 2) {
            const intervals = [];
            for (let i = 1; i < peakTimes.length; i++) {
              intervals.push(peakTimes[i] - peakTimes[i - 1]);
            }
            const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            let bpm = 60 / avgInterval;

            if (bpm >= minBPM && bpm <= maxBPM) {
              bpmHistory.push(bpm);
              if (bpmHistory.length > rollingAverageSize) {
                bpmHistory.shift();
              }
              const avgBPM = bpmHistory.reduce((a, b) => a + b, 0) / bpmHistory.length;
              updateBPMDisplay(avgBPM.toFixed(1));
            }
          }
        }
      }, 100); // Analyze every 100 ms
    }

    function updateBPMDisplay(bpm) {
      document.getElementById('bpm').innerText = `BPM: ${bpm}`;
    }
  </script>
</body>
</html>

