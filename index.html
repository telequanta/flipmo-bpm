<script>
let audioContext, analyser, source, bandpassFilter;
let dataArray;
let peakTimes = [];
let bpmDisplay = document.getElementById('bpm');
let bpmTimer;
const PEAK_THRESHOLD = 0.005; // LOWERED sensitivity (was 0.02)
const MIN_PEAK_INTERVAL = 0.4; // 150 BPM upper limit
const MAX_PEAK_INTERVAL = 0.6; // 100 BPM lower limit
const EXPECTED_BPM_RANGE = [100, 135];
let lastPeakTime = 0;

async function startMic() {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  source = audioContext.createMediaStreamSource(stream);

  // Bandpass filter shifted LOWER to focus on kicks/claps
  bandpassFilter = audioContext.createBiquadFilter();
  bandpassFilter.type = 'bandpass';
  bandpassFilter.frequency.value = 200; // Center on 200Hz
  bandpassFilter.Q.value = 0.7; // Wider to catch some snares too

  analyser = audioContext.createAnalyser();
  analyser.fftSize = 1024;
  dataArray = new Uint8Array(analyser.frequencyBinCount);

  source.connect(bandpassFilter);
  bandpassFilter.connect(analyser);

  detectBeats();
  bpmTimer = setInterval(updateBPMDisplay, 2000); // Update display every 2 sec
}

function detectBeats() {
  analyser.getByteTimeDomainData(dataArray);

  let energy = 0;
  for (let i = 0; i < dataArray.length; i++) {
    let val = (dataArray[i] - 128) / 128;
    energy += val * val;
  }
  energy /= dataArray.length;

  const currentTime = audioContext.currentTime;

  if (energy > PEAK_THRESHOLD) {
    let interval = currentTime - lastPeakTime;

    if (interval > MIN_PEAK_INTERVAL && interval < MAX_PEAK_INTERVAL) {
      peakTimes.push(currentTime);
      lastPeakTime = currentTime;

      // Keep the last ~40 beats (10 bars)
      if (peakTimes.length > 40) {
        peakTimes.shift();
      }
    }
  }

  requestAnimationFrame(detectBeats);
}

function updateBPMDisplay() {
  if (peakTimes.length < 4) {
    bpmDisplay.textContent = "-- BPM"; // Not enough data yet
    return;
  }

  let intervals = [];
  for (let i = 1; i < peakTimes.length; i++) {
    intervals.push(peakTimes[i] - peakTimes[i - 1]);
  }

  const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
  let bpm = 60 / avgInterval;

  if (bpm >= EXPECTED_BPM_RANGE[0] && bpm <= EXPECTED_BPM_RANGE[1]) {
    bpmDisplay.textContent = bpm.toFixed(1) + " BPM";
  } else {
    bpmDisplay.textContent = "-- BPM"; // Out of expected range
  }
}

function resetBPM() {
  peakTimes = [];
  bpmDisplay.textContent = "-- BPM";
  clearInterval(bpmTimer);
}
</script>
